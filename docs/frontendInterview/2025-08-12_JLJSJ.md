# 精灵计算机 - 前端面试

> 面试时间：2025-08-12
>
> 公司全称：广州精灵计算机系统有限公司
>
> 公司位置：广州天河区东宏国际广场 901

## 面试题

###### uniapp 小程序中性能优化方式有哪些？

::: details 查看答案
1. 长列表使用虚拟列表或 uv-ui 组件库的虚拟列表组件。
```javascript
// 长列表使用虚拟列表
<scroll-view scroll-y style="height: 100vh">
  <view v-for="(item, index) in largeList" :key="index" 
        style="height: 100px">{{item.name}}</view>
</scroll-view>

// 或者使用uniapp的uv-ui虚拟列表组件
<uv-virtual-list :list="largeList" :itemHeight="100">
  <template v-slot="{ item }">
    <view>{{item.name}}</view>
  </template>
</uv-virtual-list>
```

2. 图片使用 webp 格式和懒加载，使用合适的图片尺寸。
```javascript
// 使用webp格式和懒加载
<image :src="imgUrl" lazy-load mode="widthFix" 
       webp="true" :show-menu-by-longpress="false"></image>

// 使用合适的图片尺寸
<image :src="imgUrl + '?width=300&quality=80'" />
```

3. 合并数据更新操作，避免频繁 setData。
```javascript
// 避免频繁 setData
this.$set(this.data, 'key1', value1) 
this.$set(this.data, 'key2', value2) 

// 合并数据更新
this.setData({
  key1: value1,
  key2: value2
}) // 优于分开调用
```

4. 使用 computed 缓存计算结果或者自定义缓存函数。
```javascript
computed: {
  filteredList() {
    // 复杂计算使用computed
    return this.list.filter(item => item.active)
  }
},

// 大数据量使用缓存
const cache = new Map()
function heavyCompute(data) {
  if (cache.has(data)) return cache.get(data)
  const result = /* 复杂计算 */
  cache.set(data, result)
  return result
}
```

5. 进行分包加载处理。
```json
// manifest.json 配置
{
  "mp-weixin": {
    "optimization": {
      "subPackages": true
    },
    "subPackages": [
      {
        "root": "packageA",
        "pages": [
          "pages/cat",
          "pages/dog"
        ]
      }
    ]
  }
}
```

6. 按需引入组件
```javascript
// 修改 pages.json
{
  "usingComponents": {
    "van-button": "/wxcomponents/vant/button/index"
  }
}

// 或使用 easycom 自动引入。在 pages.json 中配置
"easycom": {
  "^u-(.*)": "@/uview-ui/components/u-$1/u-$1.vue"
}
```

7. 多个组件发送完全一个的请求时，进行请求合并与缓存操作。
```javascript
// 封装请求函数
const requestQueue = new Map()

async function cachedRequest(url, params) {
  const key = JSON.stringify({url, params})
  if (requestQueue.has(key)) {
    return requestQueue.get(key)
  }
  const promise = uni.request({ url, data: params })
  requestQueue.set(key, promise)
  try {
    const res = await promise
    return res
  } finally {
    requestQueue.delete(key)
  }
}
```

8. 应用启动时预加载关键数据。
```javascript
// App.vue 中预加载
onLaunch() {
  this.preloadData()
},

methods: {
  async preloadData() {
    const cache = uni.getStorageSync('preloadData')
    if (!cache || Date.now() - cache.time > 3600000) {
      const data = await this.$api.getPreloadData()
      uni.setStorageSync('preloadData', {
        data,
        time: Date.now()
      })
    }
  }
}
```

9. 页面卸载时及时清理全局事件。
```javascript
onUnload() {
  // 关闭 eventBus 事件
  this.$eventBus.off('someEvent', this.handler)
  // 清除定时器
  clearInterval(this.timer)
}
```

10. 使用 Web Worker 处理大数据。
```javascript
// 使用 Web Worker 处理大数据
const worker = new Worker('/utils/worker.js')
worker.postMessage(largeData)
worker.onmessage = (e) => {
  this.result = e.data
}

// utils/worker.js
self.onmessage = function(e) {
  // 处理大数据逻辑
  const result = processLargeData(e.data)
  self.postMessage(result)
}
```
:::

---

###### 你是如何做前端技术选型决策的？

::: details 查看答案
首先是分析目前各团队正在开发的主要项目所使用的技术栈，了解大家对各技术栈的熟悉程度，然后再关注核心框架的社区活跃度、周边生态情况以及长期支持程度，最后需要考虑框架对应构建工具的编译速度、HMR 效率等。
:::

---



## 笔试题
