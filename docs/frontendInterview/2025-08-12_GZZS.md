# 广州智算 - 前端面试

> 面试时间：2025-08-12（第一轮技术面）、2025-08-14（第二轮技术面）
>
> 公司全称：广州智算信息技术有限公司
>
> 公司位置：广州黄浦区广州智算信息技术有限公司绿地中央广场C1栋04层

## 面试题

###### 如何实现 AI 助手打字机的效果？

::: details 查看答案
基于 `@microsoft/fetch-event-source` 实现 SSE 通信效果，onmessage 方法中获取到服务端不断响应的内容后进行拼接展示到页面上。
:::

---

###### 如何处理 AI 助手流式输出返回的 markdown 内容？

::: details 查看答案
基于 `@kangc/v-md-editor/lib/codemirror-editor` 封装公共的 MarkDown 编辑器组件展示基础的 markdown内容，对于返回的代码内容，借助 `highlight.js` 实现代码的语法高亮。
:::

---

###### React 类组件与函数组件的区别？

::: details 查看答案
代码组织。类组件逻辑分散在各个生命周期方法中；函数组件逻辑可以按相关性组织在一起。

this 绑定问题。类组件需要处理方法的 this 绑定；函数组件无 this 绑定问题。

响应式。类组件 this.state 定义和获取数据，this.setState 修改数据；函数组件通过 useState Hook。

生命周期。类组件需要记多个生命周期方法（如 componentDidMount、componentDidMount、componentDiUpdate 等）；函数组件只需要一个 useEffect 即可。
:::

---

###### 可视化大屏如何做适配？

::: details 查看答案
使用 CSS 缩放
```css
/* 以1920×1080为设计稿基准 */
.wrapper {
  width: 1920px;
  height: 1080px;
  transform-origin: 0 0;
  transform: scale(calc(100vw / 1920), calc(100vh / 1080));
}
```

:::

---

###### 说说你用 WebGis 实现无人机巡航路线回放的过程？

::: details 查看答案
首先通过坐标转换函数将 GS84 坐标转换为 GZ200 坐标，循环遍历无人机飞行数据中的所有 [x, y, z] 空间坐标点并在地图中进行打点和连接操作，在初始坐标位置叠加无人机图标和视频组件，当播放视频时，通过定时器每秒钟切换无人机图标和视频组件的位置，实现视频播放的画面与地图位置能够一一对应。
:::

---

###### 介绍你做的 ERP 系统的整个业务流程？

::: details 查看答案
库存管理、运输管理、生产管理、采购管理、销售管理、财务管理、报表中心。
:::

---

###### 说说你们项目双 token 校验是怎么实现的？

::: details 查看答案
用户进行登录后，将后端返回的 token 和 refreshToken（刷新 token）存到本地储存中。当 token 失效时，发送请求后会执行响应拦截器的错误函数，在错误拦截器中拦截到状态码 401 则根据 refreshToken 重新去获取新的 token，如果能获取到新的 token，则将新的 token 存入本地，并重发刚刚错误的请求，如果获取不到新的 token，说明 refreshToken 失效了，则弹出退出登录的提示框。
:::

---

###### 页面上有 10 个小球，一排 5 个，从某一个小球开始按下鼠标进行划动，划到另一个小球后松开鼠标，将它俩以及它俩之间被划到过的小球改变颜色，怎么实现？

::: details 查看答案
mousedown 记录起始小球，mousemove 实时追踪并更新高亮状态，moseup 确认最终需要改变颜色的所有小球
```html
<!DOCTYPE html>
<html>
<head>
  <style>
    .ball-container { display: flex; flex-direction: column; gap: 20px; margin: 30px; }
    .ball-row { display: flex; gap: 15px; }
    .ball { width: 50px; height: 50px; border-radius: 50%; background: #ccc; cursor: pointer; transition: background 0.2s; }
    .ball.selected { background: #f06; }
    .ball.highlight { background: #ff9999; }
    .instructions { margin: 20px; padding: 15px; background: #f5f5f5; border-radius: 5px; }
  </style>
</head>
<body>
  <div class="instructions">
    <h3>操作说明：</h3>
    <p>1. 点击一个小球并保持按下</p>
    <p>2. 拖动到另一个小球</p>
    <p>3. 松开鼠标，起始球、结束球及中间球都会变色</p>
  </div>
  
  <div class="ball-container">
    <div class="ball-row">
      <div class="ball" data-index="0"></div>
      <div class="ball" data-index="1"></div>
      <div class="ball" data-index="2"></div>
      <div class="ball" data-index="3"></div>
      <div class="ball" data-index="4"></div>
    </div>
    <div class="ball-row">
      <div class="ball" data-index="5"></div>
      <div class="ball" data-index="6"></div>
      <div class="ball" data-index="7"></div>
      <div class="ball" data-index="8"></div>
      <div class="ball" data-index="9"></div>
    </div>
  </div>

  <script>
    const balls = document.querySelectorAll('.ball');
    let isDragging = false;
    let startBall = null;
    let currentHoverBall = null;

    // 事件监听
    balls.forEach(ball => {
      ball.addEventListener('mousedown', (e) => {
        isDragging = true;
        startBall = e.target;
        clearSelection();
        e.target.classList.add('selected');
        e.preventDefault();
      });
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const hovered = document.elementFromPoint(e.clientX, e.clientY);
      if (hovered && hovered.classList.contains('ball')) {
        currentHoverBall = hovered;
        updateSelection();
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        finalizeSelection();
      }
    });

    // 功能函数
    function clearSelection() {
      balls.forEach(b => b.classList.remove('selected', 'highlight'));
    }

    function updateSelection() {
      clearSelection();
      const startIdx = parseInt(startBall.dataset.index);
      const endIdx = parseInt(currentHoverBall.dataset.index);
      
      for (let i = Math.min(startIdx, endIdx); i <= Math.max(startIdx, endIdx); i++) {
        document.querySelector(`.ball[data-index="${i}"]`).classList.add('highlight');
      }
      
      startBall.classList.add('selected');
      currentHoverBall.classList.add('selected');
    }

    function finalizeSelection() {
      const startIdx = parseInt(startBall.dataset.index);
      const endIdx = parseInt(currentHoverBall.dataset.index);
      
      clearSelection();
      for (let i = Math.min(startIdx, endIdx); i <= Math.max(startIdx, endIdx); i++) {
        document.querySelector(`.ball[data-index="${i}"]`).classList.add('selected');
      }
    }
  </script>
</body>
</html>
```
:::

---

###### 如果让你自己实现从小到大的排序算法，你怎么实现？

::: details 查看答案
1. 冒泡排序：重复遍历数组，比较相邻元素，如果顺序不对就交换，每次遍历将最大的元素“冒泡”到最后。
```javascript
function bubbleSort(arr) {
  // 数组长度
  const n = arr.length
  // 比较轮数 = 数组长度 - 1
  for (let i = 0; i < n - 1; i++) {
    // 第 j 论比较次数 = 数组长度 - 1 - i
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换相邻元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
  return arr;
}

// 示例
console.log(bubbleSort([1, 5, 7, 3]))
```

2. 选择排序：每次遍历前都假设第一个为最小值，然后遍历找出真正的最小值与第一个进行交换。
```javascript
function selectionSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    // 先假设第一个元素为最小值
    let minIndex = i
    // 从第二个元素开始遍历比较，遇到更小的则替换最小值下标
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    // 交换当前元素与最小元素
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
  }
  return arr;
}

// 示例
console.log(selectionSort([1, 5, 7, 3]))
```

3. 插入排序：将数组分为已排序和未排序两部分，每次取未排序部分的第一个元素插入到已排序部分的正确位置。
```javascript
function insertionSort(arr) {
  const n = arr.length
  for (let i = 1; i < n; i++) {
    let current = arr[i]
    let j = i - 1
    // 将当前元素插入到已排序部分的正确位置
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = current
  }
  return arr
}

// 示例
console.log(insertionSort([1, 5, 7, 3]))
```

4. 归并排序：采用分治法，将数组分成两半，分别排序，然后合并。
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr
  
  const mid = Math.floor(arr.length / 2)
  const left = mergeSort(arr.slice(0, mid))
  const right = mergeSort(arr.slice(mid))
  
  return merge(left, right)
}

function merge(left, right) {
  let result = []
  let i = 0, j = 0
  
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i])
      i++
    } else {
      result.push(right[j])
      j++
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j))
}

// 示例
console.log(mergeSort([1, 5, 7, 3]))
```

5. 快速排序：选择一个基准元素（pivot），将数组分为小于基准和大于基准的两部分，递归地对两部分进行排序。
```javascript
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partition(arr, left, right)
    quickSort(arr, left, pivotIndex - 1)
    quickSort(arr, pivotIndex + 1, right)
  }
  return arr
}

function partition(arr, left, right) {
  const pivot = arr[right]
  let i = left
  for (let j = left; j < right; j++) {

    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]]
      i++
    }
  }
  
  [arr[i], arr[right]] = [arr[right], arr[i]]
  return i
}

// 示例
console.log(quickSort([1, 5, 7, 3]))
```

6. 堆排序：构建最大堆，重复从堆中提取最大元素并重建堆。
```javascript
function heapSort(arr) {
  const n = arr.length;
  
  // 构建最大堆
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i)
  }
  
  // 逐个提取元素
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]]
    heapify(arr, i, 0)
  }
  
  return arr
}

function heapify(arr, n, i) {
  let largest = i
  const left = 2 * i + 1
  const right = 2 * i + 2
  
  if (left < n && arr[left] > arr[largest]) {
    largest = left
  }
  
  if (right < n && arr[right] > arr[largest]) {
    largest = right
  }
  
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]]
    heapify(arr, n, largest)
  }
}

// 示例
console.log(heapSort([1, 5, 7, 3]))
```
:::

---

###### 说说你们的工作流引擎是怎么实现的？

::: details 查看答案
使用 `@antv/x6` 作为底层画布，`jsplumb` 处理节点的拖拽、连接逻辑。
:::

---


## 笔试题

###### 什么是正向代理、反向代理？

::: details 查看答案
正向代理：代理客户端，隐藏客户端身份。
反向代理：代理服务端，隐藏服务器身份。
:::

---

###### 编写一个函数，实现传入 tree 树形结构的数据和节点 id，能够根据 id 找到节点并返回节点？

::: details 查看答案
```javascript
function getNodeById(tree, id) {
  // 循环当前这一层中数组的每个节点
  for(const node of tree) {
    // 如果根据 id 找到了节点，直接返回
    if(node.id === id) return node
    // 找不到节点时，如果节点的子节点长度不为 0，则递归查找
    const foundNode = node.children?.length && getNodeById(node.children, id)
    // 找到节点，直接返回
    if(foundNode) return foundNode
  }
}
```
:::

---

###### 给前端十万条数据，然后做到渲染不卡顿？

::: details 查看答案
```javascript
使用虚拟列表技术，先渲染可视区的数据和上下非可视区各20~30条数据。
```
:::

---

###### 前端代码部署后，如何通知用户更新版本？

::: details 查看答案
方案一：轮询对比版本信息。public 目录下放置 version.json 文件记录版本信息，前端通过 `setInterval` 定时器 5 分钟执行一次 `fetch('/version.json?t=' + Date.now())` 获取最新版本信息进行比较，如果版本更新了则展示更新通知。

方案二：使用 Service Worker 进行进行监测。

方案三：WebSocket 实时推送。

方案四：Nginx 响应头添加版本标记。
:::

---


