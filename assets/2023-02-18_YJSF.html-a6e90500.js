import{_ as a,p as l,q as t,a1 as i}from"./framework-596b4733.js";const d={};function o(p,e){return l(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="悠久商服-前端面试" tabindex="-1"><a class="header-anchor" href="#悠久商服-前端面试" aria-hidden="true">#</a> 悠久商服 - 前端面试</h1><blockquote><p>面试时间：2023-03-18</p><p>公司全称：广州悠久商服科技有限公司</p><p>公司位置：广州天河区棠下悠久商服</p></blockquote><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><h6 id="css中哪些属性可继承" tabindex="-1"><a class="header-anchor" href="#css中哪些属性可继承" aria-hidden="true">#</a> CSS中哪些属性可继承？</h6><details class="custom-container details"><summary>查看答案</summary><p>字体属性：font 系列（font-style、font-size、font-family 等）</p><p>文本属性：color、line-height、text-align、text-indent</p><p>可见性属性：visibility</p><p>列表属性：list-style 系列（list-style-type、list-style-position、list-style-image）</p><p>注：继承中特殊的 <code>a</code> 标签颜色不会继承，<code>h1~h6</code> 标签的字体大小不会继承</p></details><hr><h6 id="css-选择器有哪些" tabindex="-1"><a class="header-anchor" href="#css-选择器有哪些" aria-hidden="true">#</a> CSS 选择器有哪些？</h6><details class="custom-container details"><summary>查看答案</summary><p>分为五大类：元素选择器、关系选择器、属性选择器、伪类选择器、伪元素选择器。</p><p>一、元素选择器：</p><ol><li>通配符选择器：<code>* {}</code></li></ol><p>选中页面中的所有元素（会影响浏览器的性能）</p><ol start="2"><li><p>标签选择器：<code>标签名 {}</code></p></li><li><p>id选择器：<code>#id {}</code></p></li><li><p>类选择器：<code>class {}</code></p></li><li><p>并集选择器：<code>选择器1, 选择器2, 选择器3, ..., 选择器n {}</code></p></li></ol><p>几个选择器选中的元素共用一套样式</p><ol start="6"><li>交集选择器：<code>选择器1.选择器2 {}</code></li></ol><p>二、关系选择器：</p><ol><li><p>子代选择器：<code>父级 &gt; 子级 {}</code></p></li><li><p>后代选择器（空格隔开）：<code>祖先元素 后代元素 {}</code></p></li><li><p>相邻选择器：<code>.pre + .next</code></p></li></ol><p>选择紧接在 .pre 元素之后的 .next 元素，并且二者具有相同的父级元素。</p><ol start="4"><li>兄弟选择器：<code>.pre ~ .next</code></li></ol><p>选择 .pre 元素后面所有的 .next 元素。</p><p>三、属性选择器：</p><ol><li><p>[name] 具有 name 属性的元素</p></li><li><p>[attr=&#39;val&#39;] 具有 attr 属性，且属性值完全等于 val 的元素</p></li><li><p>[attr^=&#39;val&#39;] 具有 attr 属性，且属性值以 val 开头。可以匹配 attr=&#39;val&#39;、attr=&#39;value&#39;</p></li><li><p>[attr$=&#39;val&#39;] 具有 attr 属性，且属性值以 val 结尾。可以匹配 attr=&#39;val&#39;、attr=&#39;a val&#39;、attr=&#39;a-val&#39;</p></li><li><p>[attr*=&#39;val&#39;] 具有 attr 属性，且属性值包含 val。可以匹配 attr=&#39;val&#39;、attr=&#39;a val&#39;、attr=&#39;a-val&#39;、attr=&#39;value&#39;</p></li><li><p>[attr~=&#39;val&#39;] 具有 attr 属性，且属性值包含 val（val 必须单独存在，不能是某个词中的一部分）。可以匹配 attr=&#39;val&#39;、attr=&#39;a val&#39;，但不能匹配 attr=&#39;a-val&#39;、attr=&#39;value&#39;</p></li><li><p>[attr|=&#39;val&#39;] 具有 attr 属性，且属性值完全等于 val，或者以 val 开头用 - 连接的词。可以匹配 attr=&#39;val&#39;、attr=&#39;val-all&#39;，但不能匹配 attr=&#39;value&#39;、attr=&#39;val all&#39;</p></li></ol><p>四、伪类选择器：</p><ol><li><p>:root 只选中 HTML 元素</p></li><li><p>:focus 元素获取焦点时得样式</p></li><li><p>:not(选择器) 选择不含有某个选择器得元素</p></li><li><p>:first-child 选中第一个子元素</p></li><li><p>:first-of-type 选中第一个指定的元素</p></li></ol><p>:first-child 与 :first-of-type 的区别：<code>p:first-child</code> 选中 p 标签中第一个子元素，<code>p:first-of-type</code> 选中第一个 p 元素。</p><ol start="6"><li><p>:last-child 选中最后一个子元素</p></li><li><p>:last-of-type 选中最后一个指定的元素</p></li><li><p>:nth-child(n) 选中第 n 个子元素</p></li><li><p>:nth-of-type(n) 选中第 n 个指定的元素</p></li></ol><ul><li>:nth-child() 和 :nth-of-type() 可以选择奇数、偶数元素</li><li>odd 选中奇数位置的元素</li><li>even 选中偶数位置的元素</li><li>2n-1 选中奇数位置的元素</li><li>2n 选中偶数位置的元素</li></ul><ol start="10"><li><p>:only-child() 选中父元素中的子元素，且父元素中必须有且只有一个子元素</p></li><li><p>:only-of-type() 选中父元素中的某个元素，且父元素中必须有且只有一个该元素</p></li><li><p>:empty 选中没有任何子元素（元素内不能有任何内容）的空元素</p></li><li><p>:checked 选中页面中被选中的单选框或复选框</p></li><li><p>disabled 选中页面中处于禁用状态的元素</p></li><li><p>:enabled 选中页面中处于可用状态的元素</p></li><li><p>:target 选中被激活的锚点</p></li></ol><p>五、伪元素选择器</p><ol><li><p>:first-letter 给元素的第一个字母添加样式</p></li><li><p>:first-line 给元素第一行添加样式</p></li><li><p>:before 在内容的前面插入伪元素。必须要与 content 一起使用，ontent 的值可以为空</p></li><li><p>:after 在内容的后面插入伪元素。必须要与 content 一起使用，content 的值可以为空</p></li></ol></details><hr><h6 id="css-水平居中的方式" tabindex="-1"><a class="header-anchor" href="#css-水平居中的方式" aria-hidden="true">#</a> CSS 水平居中的方式</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p><code>margin: 0 auto;</code></p></li><li><p>子绝父相 + left 左偏移 + margin-left 回退。具体实现：子元素绝对定位 <code>position: absolute;</code>，父元素相对定位 <code>position: reactive;</code>，子元素 <code>left: 50%;</code> 且 <code>margin-left: 自身宽度一半的负值</code></p></li><li><p>子绝父相 + left 左偏移 + transform: translateX()。具体实现： 子元素绝对定位 <code>position: absolute;</code>，父元素相对定位 <code>position: reactive;</code>，子元素 <code>left: 50%;</code> 且 <code>transform: translateX(50%);</code></p></li><li><p><code>text-algin: center;</code> + <code>display: inline-block;</code>。具体实现：父元素 <code>text-align: center;</code>，子元素 <code>display: inline-block;</code></p></li><li><p><code>display: flex;</code> + <code>justify-content: center;</code></p></li></ol></details><hr><h6 id="对-css-盒模型的理解" tabindex="-1"><a class="header-anchor" href="#对-css-盒模型的理解" aria-hidden="true">#</a> 对 CSS 盒模型的理解</h6><details class="custom-container details"><summary>查看答案</summary><p>所有 HTML 元素都可以看作一个盒子，它的组成包括：content、padding、border、margin。</p></details><hr><h6 id="computed-与-watch-的区别" tabindex="-1"><a class="header-anchor" href="#computed-与-watch-的区别" aria-hidden="true">#</a> computed 与 watch 的区别</h6><details class="custom-container details"><summary>查看答案</summary><p>computed 计算属性基于 data 中声明过或 props 传递过来的数据通过计算得到一个新值，新值会根据已知值得变化而变化，且 computed 具有缓存功能，多次使用同一个 computed 计算得属性值，只会执行一次 computed 内定义的 function，直到依赖项改变才会重新计算。</p><p>watch 监听属性可以用来监听 data、props、computed 内的数据变化，然后执行某些具体的业务操作，当属性变化时，监听的的回调函数会自动执行。</p><p>对于多个监听对象要进行同一操作，watch 需要监听多次，而 computed 只需要执行一次。 在执行异步或开销比较大的操作时，watch 方式更合适。</p></details><hr><h6 id="提供数组去重的-3-种方式" tabindex="-1"><a class="header-anchor" href="#提供数组去重的-3-种方式" aria-hidden="true">#</a> 提供数组去重的 3 种方式</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>双重遍历 + <code>splice()</code> 去重</p></li><li><p><code>filter()</code> + <code>indexOf()</code> 去重</p></li><li><p><code>reduce()</code> + <code>includes()</code> 去重</p></li><li><p><code>new Set()</code> 去重</p></li></ol></details><hr><h6 id="原型和原型链的理解" tabindex="-1"><a class="header-anchor" href="#原型和原型链的理解" aria-hidden="true">#</a> 原型和原型链的理解</h6><details class="custom-container details"><summary>查看答案</summary><p>原型：对象创建时，会关联另一个对象，这个对象就是原型对象，创建的对象会继承原型对象的属性和方法。</p><p>原型链：当访问对象的某个属性或者方法时，如果在对象自身上找不到，就会到对象的原型上查找，如果也找不到，就会到原型的原型上查找，一直找到顶层为止，就构成了一条链路，这就是原型链。</p></details><hr><h6 id="this-指向的几种情况" tabindex="-1"><a class="header-anchor" href="#this-指向的几种情况" aria-hidden="true">#</a> this 指向的几种情况</h6><details class="custom-container details"><summary>查看答案</summary><p>全局环境中定义的函数，this 指向 window。</p><p>new 关键字创建的实例对象，this 指向这个实例对象。</p><p>如果使用 apply()、call()、bind() 进行借调操作，this 指向这些方法第一个参数所绑定的对象。</p><p>箭头函数由于没有 this，它内部的 this 指向外层函数的 this，如果外层函数也没有 this，逐层向上找，直到 window 对象为止。</p></details><hr><h6 id="js-继承的理解" tabindex="-1"><a class="header-anchor" href="#js-继承的理解" aria-hidden="true">#</a> JS 继承的理解</h6><details class="custom-container details"><summary>查看答案</summary><p>JS 继承：子类从父类中获取属性和方法。</p></details><hr><h2 id="笔试题" tabindex="-1"><a class="header-anchor" href="#笔试题" aria-hidden="true">#</a> 笔试题</h2><h6 id="new-的过程" tabindex="-1"><a class="header-anchor" href="#new-的过程" aria-hidden="true">#</a> new 的过程</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>创建一个空对象；</p></li><li><p>将空对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code> 属性；</p></li><li><p>调用构造函数并改变 this 指向，让它指向我们新创建的这个空对象；</p></li><li><p>返回这个空对象。</p></li></ol></details><hr><h6 id="js-判断数据类型的方法有哪些" tabindex="-1"><a class="header-anchor" href="#js-判断数据类型的方法有哪些" aria-hidden="true">#</a> JS 判断数据类型的方法有哪些？</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p><code>typeof</code>。</p></li><li><p><code>instanceof</code>。</p></li><li><p><code>Object.prototype.toString.call()</code>。</p></li></ol></details><hr>',37)])])}const s=a(d,[["render",o],["__file","2023-02-18_YJSF.html.vue"]]);export{s as default};
