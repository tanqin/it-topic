import{_ as e,p as s,q as r,a1 as t}from"./framework-596b4733.js";const d={};function i(n,a){return s(),r("div",null,[...a[0]||(a[0]=[t(`<h1 id="飞项科技-前端面试" tabindex="-1"><a class="header-anchor" href="#飞项科技-前端面试" aria-hidden="true">#</a> 飞项科技 - 前端面试</h1><blockquote><p>面试时间：2023-04-07</p><p>公司全称：飞项科技（广州）有限公司</p><p>公司位置：大观中路492号慧创百思产业园A区241</p></blockquote><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><h6 id="谈谈你对原型链的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对原型链的理解" aria-hidden="true">#</a> 谈谈你对原型链的理解</h6><details class="custom-container details"><summary>查看答案</summary><p>当访问对象的某个属性或者方法时，如果在对象自身上找不到，就会到对象的原型上查找，如果也找不到，就会到原型的原型上查找，一直找到顶层为止，就构成了一条链路，这就是原型链。</p></details><hr><h6 id="es5、es6-的继承" tabindex="-1"><a class="header-anchor" href="#es5、es6-的继承" aria-hidden="true">#</a> ES5、ES6 的继承</h6><details class="custom-container details"><summary>查看答案</summary><p>ES5 包含 6 种继承方式。分别为原型链继承、构造函数继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。</p><p>ES6 通过 extends 关键字进行继承。</p></details><hr><h6 id="对象如何进行解构" tabindex="-1"><a class="header-anchor" href="#对象如何进行解构" aria-hidden="true">#</a> 对象如何进行解构？</h6><details class="custom-container details"><summary>查看答案</summary><p>将一个对象中的属性显式的写在另一个对象中。如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span>  <span class="token operator">=</span> userInfo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><hr><h6 id="如何让一个空对象-2-4" tabindex="-1"><a class="header-anchor" href="#如何让一个空对象-2-4" aria-hidden="true">#</a> 如何让一个空对象 + 2 === 4？</h6><details class="custom-container details"><summary>查看答案</summary><p><code>JSON.stringify({}).length + 2 === 4</code></p></details><hr><h6 id="当父组件数据变化与子组件无关时-如何避免子组件重新渲染" tabindex="-1"><a class="header-anchor" href="#当父组件数据变化与子组件无关时-如何避免子组件重新渲染" aria-hidden="true">#</a> 当父组件数据变化与子组件无关时，如何避免子组件重新渲染？</h6><details class="custom-container details"><summary>查看答案</summary><p>可以用到 React.memo、useMemo、useCallback 一起来解决。</p></details><hr><h6 id="写过哪些自定义-hooks" tabindex="-1"><a class="header-anchor" href="#写过哪些自定义-hooks" aria-hidden="true">#</a> 写过哪些自定义 Hooks？</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>页面滚动位置监听 Hooks。</p></li><li><p>全局弹窗 Hooks。</p></li><li><p>权限校验 Hooks。</p></li></ol></details><hr><h6 id="谈谈你对错误边界的理解。如何实现错误边界" tabindex="-1"><a class="header-anchor" href="#谈谈你对错误边界的理解。如何实现错误边界" aria-hidden="true">#</a> 谈谈你对错误边界的理解。如何实现错误边界？</h6><details class="custom-container details"><summary>查看答案</summary><p>错误边界是一个 React 组件，它可以捕获其子组件树任何位置的 JS 错误，并打印这些错误，同时显示降级 UI，而不去渲染那些已崩溃的子组件树。</p><p>方式一（手写错误边界组件）：一个 <code>class</code> 组件中只要定义了 <code>static getDerivedStateFromError()</code> 或 <code>componentDidCatch()</code> 生命周期中任何一个即可成为一个错误边界。</p><p>方式二（使用第三方库）：react-error-boundary</p></details><hr><h6 id="react-组件生命周期" tabindex="-1"><a class="header-anchor" href="#react-组件生命周期" aria-hidden="true">#</a> React 组件生命周期</h6><details class="custom-container details"><summary>查看答案</summary><p>挂载阶段：constructor() -&gt; render()、componentDidMount()</p><p>更新阶段：componentWilReceiveProps() -&gt; shouldComponentUpdate() -&gt; componentWillUpdate() -&gt; render() -&gt; componentDidUpdate()</p><p>卸载阶段：componentWillUnmount()</p></details><hr><h6 id="说说你对-react-hook-的闭包陷阱的理解-有哪些解决方案" tabindex="-1"><a class="header-anchor" href="#说说你对-react-hook-的闭包陷阱的理解-有哪些解决方案" aria-hidden="true">#</a> 说说你对 React Hook 的闭包陷阱的理解，有哪些解决方案？</h6><details class="custom-container details"><summary>查看答案</summary><p>闭包陷阱：由于闭包的存在，导致无法获取 state 更新后的值。</p><p>解决方案：</p><p>方案一：使用 <code>useRef()</code> 绑定数据。</p><p>方案二：<code>useState()</code> 中的数据定义为一个对象。</p></details><hr><h6 id="开发的过程中你用到过哪些设计模式以及具体的应用场景" tabindex="-1"><a class="header-anchor" href="#开发的过程中你用到过哪些设计模式以及具体的应用场景" aria-hidden="true">#</a> 开发的过程中你用到过哪些设计模式以及具体的应用场景？</h6><details class="custom-container details"><summary>查看答案</summary><p>适配器模式。</p><p>单例模式。</p><p>代理模式。</p><p>发布订阅模式。</p><p>观察者模式。</p><p>装饰者模式。</p></details><hr><h6 id="在-umi-中如何配置-dva" tabindex="-1"><a class="header-anchor" href="#在-umi-中如何配置-dva" aria-hidden="true">#</a> 在 umi 中如何配置 dva？</h6><details class="custom-container details"><summary>查看答案</summary><p>在一个配置文件中定义一个对象，包含 state、reducers、effects 属性并导出，这就是一个 dva 配置。</p></details><hr><h6 id="单元测试的流程逻辑" tabindex="-1"><a class="header-anchor" href="#单元测试的流程逻辑" aria-hidden="true">#</a> 单元测试的流程逻辑</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>确定输入和输出</p></li><li><p>准备测试数据</p></li><li><p>编写测试用例</p></li><li><p>验证测试结果</p></li></ol></details><hr><h2 id="笔试题" tabindex="-1"><a class="header-anchor" href="#笔试题" aria-hidden="true">#</a> 笔试题</h2>`,40)])])}const o=e(d,[["render",i],["__file","2023-04-07_FXKJ.html.vue"]]);export{o as default};
