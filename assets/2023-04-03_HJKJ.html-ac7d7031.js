import{_ as d,M as r,p as o,q as l,a1 as t,R as a,t as s,N as p}from"./framework-596b4733.js";const n={},u={class:"custom-container details"},c={href:"https://blog.csdn.net/bb_xiaxia1998/article/details/127169486",target:"_blank",rel:"noopener noreferrer"};function h(m,e){const i=r("ExternalLinkIcon");return o(),l("div",null,[e[4]||(e[4]=t('<h1 id="宏景科技-前端面试" tabindex="-1"><a class="header-anchor" href="#宏景科技-前端面试" aria-hidden="true">#</a> 宏景科技 - 前端面试</h1><blockquote><p>面试时间：2023-04-03</p><p>公司全称：宏景科技股份有限公司</p><p>公司位置：广州黄浦区创意大厦B27楼</p></blockquote><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><p>老同事了，技术面尬聊。</p><h2 id="笔试题" tabindex="-1"><a class="header-anchor" href="#笔试题" aria-hidden="true">#</a> 笔试题</h2><h6 id="v-show-和-v-if-的区别-v-show-和-keep-alive-的区别" tabindex="-1"><a class="header-anchor" href="#v-show-和-v-if-的区别-v-show-和-keep-alive-的区别" aria-hidden="true">#</a> v-show 和 v-if 的区别？v-show 和 keep-alive 的区别？</h6><details class="custom-container details"><summary>查看答案</summary><p>v-show 通过 CSS 属性 <code>display</code> 控制元素显隐。</p><p>v-if 通过元素创建和销毁控制元素显隐。</p><p>keep-alive 是 vue 框架层级进行的 JS 对象渲染。</p></details><hr><h6 id="为何-v-for-要用-key" tabindex="-1"><a class="header-anchor" href="#为何-v-for-要用-key" aria-hidden="true">#</a> 为何 v-for 要用 key？</h6><details class="custom-container details"><summary>查看答案</summary><p>使用 key 作为唯一标识，为了高效的更新虚拟 DOM。</p></details><hr><h6 id="简述vue组件生命周期-有子组件的情况" tabindex="-1"><a class="header-anchor" href="#简述vue组件生命周期-有子组件的情况" aria-hidden="true">#</a> 简述Vue组件生命周期（有子组件的情况）</h6><details class="custom-container details"><summary>查看答案</summary><p>一、加载渲染过程</p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted.</p><p>二、子组件更新过程</p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p>三、父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p><p>四、销毁过程</p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></details><hr><h6 id="描述组件渲染和更新过程" tabindex="-1"><a class="header-anchor" href="#描述组件渲染和更新过程" aria-hidden="true">#</a> 描述组件渲染和更新过程</h6><details class="custom-container details"><summary>查看答案</summary><p>渲染过程：</p><ol><li><p>解析模板为 render 函数；</p></li><li><p>触发响应式，监听 data 属性 getter，setter；</p></li><li><p>执行 render 函数，生成 vnode, patch(elem, vnode)。</p></li></ol><p>更新过程：</p><ol><li><p>修改 data，触发 setter；</p></li><li><p>重新执行 render 函数，生成 newVnode；</p></li><li><p>patch(vnode, newVnode)。</p></li></ol></details><hr><h6 id="双向数据绑定-v-model-的实现原理" tabindex="-1"><a class="header-anchor" href="#双向数据绑定-v-model-的实现原理" aria-hidden="true">#</a> 双向数据绑定 v-model 的实现原理</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>v-bind 绑定一个 value 属性；</p></li><li><p>v-on 给当前元素绑定 input 事件，使用 <code>$event.target.value</code> 给变量重新赋值。</p></li></ol></details><hr><h6 id="computed-有何特点-computed-和-watch-的区别-computed-和-methods-的区别" tabindex="-1"><a class="header-anchor" href="#computed-有何特点-computed-和-watch-的区别-computed-和-methods-的区别" aria-hidden="true">#</a> computed 有何特点，computed 和 watch 的区别，computed 和 methods 的区别</h6><details class="custom-container details"><summary>查看答案</summary><p>computed 计算属性基于 data 中声明过或 props 传递过来的数据通过计算得到一个新值，新值会根据已知值得变化而变化，且 computed 具有缓存功能，多次使用同一个 computed 计算得属性值，只会执行一次 computed 内定义的 function，直到依赖项改变才会重新计算。</p><p>computed 和 watch 的区别：对于多个监听对象要进行同一操作，watch 需要监听多次，而 computed 只需要执行一次。在执行异步或开销比较大的操作时，watch 方式更合适。</p><p>computed 和 methods 的区别：computed 只有依赖项改变才会重新计算，methods 每次调用都会执行。</p></details><hr><h6 id="vue-组件之间的通信方式" tabindex="-1"><a class="header-anchor" href="#vue-组件之间的通信方式" aria-hidden="true">#</a> Vue 组件之间的通信方式</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>通过 props 传递</p></li><li><p>通过 <code>$emit</code> 触发自定义事件传递</p></li><li><p>使用 ref</p></li><li><p>EventBus</p></li><li><p>$parent 或者 $root</p></li><li><p><code>v-bind=&quot;$attrs&quot;</code> 和 <code>v-on=&quot;$listeners&quot;</code></p></li><li><p>Provide 和 Inject</p></li><li><p>Vuex 或 Pinia</p></li></ol></details><hr><h6 id="何时需要使用-keep-alive" tabindex="-1"><a class="header-anchor" href="#何时需要使用-keep-alive" aria-hidden="true">#</a> 何时需要使用 keep-alive？</h6><details class="custom-container details"><summary>查看答案</summary><p>进行组件缓存，优化性能时。</p></details><hr><h6 id="何时需要使用-beforedestroy" tabindex="-1"><a class="header-anchor" href="#何时需要使用-beforedestroy" aria-hidden="true">#</a> 何时需要使用 beforeDestroy？</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p>清除定时器</p></li><li><p>解绑 $on</p></li><li><p>接触事件绑定</p></li></ol></details><hr><h6 id="vue-如何监听数组变化" tabindex="-1"><a class="header-anchor" href="#vue-如何监听数组变化" aria-hidden="true">#</a> Vue 如何监听数组变化？</h6>',33)),a("details",u,[e[1]||(e[1]=a("summary",null,"查看答案",-1)),a("p",null,[a("a",c,[e[0]||(e[0]=s("Vue是怎样监听数组的变化的？",-1)),p(i)])]),e[2]||(e[2]=a("p",null,"通过重写数组方法实现。步骤如下：",-1)),e[3]||(e[3]=a("ol",null,[a("li",null,[a("p",null,"先获取原生 Array 的原型方法，因为拦截后还是需要原生的方法帮我们实现数组的变化。")]),a("li",null,[a("p",null,"对 Array 的原型方法使用 Object.defineProperty 做一些拦截操作。")]),a("li",null,[a("p",null,"把需要被拦截的 Array 类型的数据原型指向改造后原型。")])],-1))]),e[5]||(e[5]=t('<hr><h6 id="vue-常见性能优化" tabindex="-1"><a class="header-anchor" href="#vue-常见性能优化" aria-hidden="true">#</a> Vue 常见性能优化</h6><details class="custom-container details"><summary>查看答案</summary><p>加载性能。1. 按需记载 2. 可视加载 3. 图片懒加载</p><p>SEO优化。1. 服务端渲染 SSR</p><p>打包优化。1. CDN 加速 2. chunk 抽取</p><p>缓存和压缩：1. 客户端缓存 2. Gzip 压缩</p></details><hr><h6 id="描述一下-vuex" tabindex="-1"><a class="header-anchor" href="#描述一下-vuex" aria-hidden="true">#</a> 描述一下 Vuex</h6><details class="custom-container details"><summary>查看答案</summary><p>“Vuex 是一个状态管理库，实现对数据的集中式管理，方便其他组件存取数据。</p></details><hr><h6 id="uni-app-页面的生命周期执行过程" tabindex="-1"><a class="header-anchor" href="#uni-app-页面的生命周期执行过程" aria-hidden="true">#</a> uni-app 页面的生命周期执行过程</h6><details class="custom-container details"><summary>查看答案</summary><p>beforeCreate -&gt; onLoad -&gt; onShow -&gt; created -&gt; beforeMount -&gt; onReady -&gt; mounted</p></details><hr><h6 id="uni-app-中的跳转方式有哪些" tabindex="-1"><a class="header-anchor" href="#uni-app-中的跳转方式有哪些" aria-hidden="true">#</a> uni-app 中的跳转方式有哪些？</h6><details class="custom-container details"><summary>查看答案</summary><p>共 6 种跳转方式。</p><ol><li><p><code>uni.navigateTo</code>：保留当前页面，跳转到应用内的某个页面。</p></li><li><p><code>uni.redirectTo</code>：关闭当前页面，跳转到应用内的某个页面。</p></li><li><p><code>uni.reLaunch</code>：关闭所有页面，打开到应用内的某个页面。</p></li><li><p><code>uni.switchTab</code>：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</p></li><li><p><code>uni.navigateBack</code>：关闭当前页面，返回上一页面或多级页面。</p></li><li><p><code>uni.preloadPage</code>：预加载页面，是一种性能优化技术。被预加载的页面，在打开时速度更快。</p></li></ol></details><hr><h6 id="uni-app-的传参方式有哪些" tabindex="-1"><a class="header-anchor" href="#uni-app-的传参方式有哪些" aria-hidden="true">#</a> uni-app 的传参方式有哪些？</h6><details class="custom-container details"><summary>查看答案</summary><ol><li><p><code>&lt;navigator&gt;</code> 标签传参</p></li><li><p><code>uni.navigateTo</code> 跳转传参</p></li><li><p><code>uni.emit()</code> 和 <code>uni.on()</code></p></li></ol></details><hr>',16))])}const f=d(n,[["render",h],["__file","2023-04-03_HJKJ.html.vue"]]);export{f as default};
